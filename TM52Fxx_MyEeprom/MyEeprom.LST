C51 COMPILER V9.56.0.0   MYEEPROM                                                          07/09/2021 14:29:49 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MYEEPROM
OBJECT MODULE PLACED IN MyEeprom.OBJ
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE MyEeprom.c OPTIMIZE(9,SIZE) BROWSE INCDIR(.\Drivers) DEBUG OBJECTEXTEND 
                    -TABS(2)

line level    source

   1          
   2          
   3          /******************************************************************************
   4          
   5            Copyright (C), 2015-2020, xxx Co., Ltd.
   6          
   7           ******************************************************************************
   8            File Name     : MyEeprom.c
   9            Version       : Initial Draft
  10            Author        : Dragon8814
  11            Created       : 2021/7/6
  12            Last Modified :
  13            Description   : 用户接口文件
  14                            根据用户程序的需要自定义修改，
  15                            比如需要测试保存数据等情况，
  16                            注意：保存的数据接口函数@MyEepromSaveAllDataUserHandle()
  17                                  保存的数据必须是所有数据，因为它会把所有数据保存
  18                                  在一个最新区域内
  19            Function List :
  20                        MyEepromSaveAllDataUserHandle
  21                        MyEepromInit
  22                        MyEepromTestHandle
  23            History       :
  24            1.Date        : 2021/7/6
  25              Author      : Dragon8814
  26              Modification: Created file
  27          
  28          ******************************************************************************/
  29          
  30          
  31          
  32          
  33          #include "MyEeprom.h"
  34          #include "TM52f82XX_Eeprom.h"
  35          #include "LED.h"
  36          
  37          
  38          
  39          void MyEepromSaveAllDataUserHandle ( unsigned char writeOnWhichArea );
  40          
  41          
  42          
  43          volatile struct eepromUser xdata  MyEeprom;
  44          
  45          
  46          
  47          /*****************************************************************************
  48           Prototype    : MyEepromInit
  49           Description  : 用户Eeprom初始化调用
  50           Input        : None
  51           Output       : None
  52           Return Value :
  53           Calls        :
  54           Called By    :
C51 COMPILER V9.56.0.0   MYEEPROM                                                          07/09/2021 14:29:49 PAGE 2   

  55          
  56            History        :
  57            1.Date         : 2021/7/6
  58              Author       : Dragon8814
  59              Modification : Created function
  60          
  61          *****************************************************************************/
  62          
  63          void MyEepromInit()
  64          {
  65   1      
  66   1        MyEeprom.SaveAllDataOnUserHandle= ( eepromSaveData* ) MyEepromSaveAllDataUserHandle;
  67   1        EepromSetup ( &MyEeprom );
  68   1      }
  69          
  70          
  71          /*****************************************************************************
  72           Prototype    : MyEepromWrite
  73           Description  : 用户Eeprom写数据操作调用
  74                          注意写入自动分配到新的区域或  在当前区域，取决于
  75                              当前的区域的写入情况
  76           Input        : unsigned int  addr 写入数据的地址@AllEepromAddr
  77                          unsigned char dat  写入数据
  78                          unsigned char isSaveAll  是否更新所有数据
  79           Output       : None
  80           Return Value :
  81           Calls        :
  82           Called By    :
  83          
  84            History        :
  85            1.Date         : 2021/7/6
  86              Author       : Dragon8814
  87              Modification : Created function
  88          
  89          *****************************************************************************/
  90          void MyEepromWrite ( unsigned int  addr,unsigned char dat,unsigned char isSaveAll )
  91          {
  92   1      
  93   1        EepromWrite (  addr, dat,  isSaveAll );
  94   1      }
  95          
  96          
  97          
  98          
  99          
 100          #if TestEeprom==TRUE
 101          /*****************************************************************************
 102           Prototype    : MyEepromTestHandle
 103           Description  : 供测试调用，用户可以自定义修改，
 104           Input        : char* from 用户自定义指针 如数码管显示缓冲区，串口打印数据数组等
 105                          unsigned int  dat
 106                          unsigned char flag  用户自定义操作命令
 107           Output       : None
 108           Return Value :
 109           Calls        :
 110           Called By    :
 111          
 112            History        :
 113            1.Date         : 2021/7/6
 114              Author       : Dragon8814
 115              Modification : Created function
 116          
C51 COMPILER V9.56.0.0   MYEEPROM                                                          07/09/2021 14:29:49 PAGE 3   

 117          *****************************************************************************/
 118          void MyEepromTestHandle ( char* from,unsigned char flag )
 119          {
 120   1        unsigned char idata t;
 121   1        unsigned char idata area=0;
 122   1        switch ( flag )
 123   1        {
 124   2      
 125   2          case 'A':
 126   2      #if TestEeprom==TRUE
 127   2            //启动时读取每个区域写入次数的
 128   2            for ( t=0; t<EepromMaxArea; t++ )
 129   2            {
 130   3              RWEepromStart();
 131   3              MyEeprom.EepromTestArea[t]= * ( MyEeprom.EepromOnRamAddress+ ( EepromStrogeValue*2*t ) );
 132   3              RWEepromEnd();
 133   3            }
 134   2            for ( t=0; t<EepromMaxArea; t++ )
 135   2            {
 136   3              if ( MyEeprom.EepromTestArea[t]<EepromMaxAreaCount )
 137   3              {
 138   4                area=t;
 139   4                break;
 140   4              }
 141   3      
 142   3      
 143   3            }
 144   2            RWEepromStart();
 145   2            MyEeprom.EepromTestWriteCount = ( unsigned long ) ( * ( MyEeprom.EepromOnRamAddress+ ( EepromStrogeValu
             -e*2* area )+CS_CountAddr_L *2  ) ) ;
 146   2            MyEeprom.EepromTestWriteCount|= ( ( ( unsigned long )  ( * ( MyEeprom.EepromOnRamAddress+ ( EepromStrog
             -eValue*2* area )+ CS_CountAddr_H *2      ) ) ) <<8 );
 147   2            MyEeprom.EepromTestWriteCount|= ( ( ( unsigned long )  ( * ( MyEeprom.EepromOnRamAddress+ ( EepromStrog
             -eValue*2* area )+ SetStableDukAddr_L *2  ) ) ) <<16 );
 148   2            MyEeprom.EepromTestWriteCount|= ( ( ( unsigned long )  ( * ( MyEeprom.EepromOnRamAddress+ ( EepromStrog
             -eValue*2* area )+ SetStableDukAddr_H *2  ) ) ) <<24 );
 149   2            RWEepromEnd();
 150   2      #endif
 151   2      
 152   2      
 153   2      
 154   2      //      MyEeprom.EepromTestWriteCount = ( unsigned long ) EepromRead( CS_CountAddr_L  ) ;
 155   2      //      MyEeprom.EepromTestWriteCount|= ( ( ( unsigned long )  EepromRead ( CS_CountAddr_H) ) <<8 );
 156   2      //      MyEeprom.EepromTestWriteCount|= ( ( ( unsigned long )  EepromRead( SetStableDukAddr_L ) )  <<16 );
 157   2      //      MyEeprom.EepromTestWriteCount|= ( ( ( unsigned long )  EepromRead(  SetStableDukAddr_H  ) ) <<24 );
 158   2      //
 159   2      
 160   2            break;
 161   2          case 'B':
 162   2            //外部给定的变量地址 数据大小即为写入的速度
 163   2            //用测试EEprom擦写极限或擦写寿命
 164   2            if ( * ( ( unsigned int* ) from ) >=40 ) //=500为5秒写一次 ，10=100ms 40=400ms
 165   2            {
 166   3              * ( ( unsigned int* ) from ) =0;
 167   3              //更新所有数据
 168   3              MyEepromWrite ( FALSE,FALSE,TRUE );
 169   3      
 170   3            }
 171   2      
 172   2            break;
 173   2          case 'C':
 174   2      #if TestEeprom==TRUE
C51 COMPILER V9.56.0.0   MYEEPROM                                                          07/09/2021 14:29:49 PAGE 4   

 175   2            //LED显示缓冲区写入特定数据
 176   2            //显示当前写入的区域 并显示每个区域当前写入的次数
 177   2            from[LED_SetTemp_COM1]=Number[MyEeprom.EepromTestArea[0]/100]; //0
 178   2            from[LED_SetTemp_COM2]=Number[MyEeprom.EepromTestArea[0]%100/10]&SEG_DPOFF;
 179   2            from[LED_SetTemp_COM3]=Number[MyEeprom.EepromTestArea[0]%10];
 180   2      
 181   2            from[LED_RealTemp_COM1]=ALL_SEG_OFF;
 182   2            from[LED_RealTemp_COM2]=Number[MyEeprom.EepromTestArea[1]/100]&SEG_DPOFF; //1
 183   2            from[LED_RealTemp_COM3]=Number[MyEeprom.EepromTestArea[1]%100/10];
 184   2            from[LED_RealTemp_COM4]=Number[MyEeprom.EepromTestArea[1]%10];
 185   2      
 186   2      
 187   2            from[LED_SetHumidity_COM1]=ALL_SEG_OFF;
 188   2            from[LED_SetHumidity_COM2]=Number[MyEeprom.EepromTestArea[2]/100];
 189   2            from[LED_RealHumidity_COM1]=Number[MyEeprom.EepromTestArea[2]%100/10];
 190   2            from[LED_RealHumidity_COM2]=Number[MyEeprom.EepromTestArea[2]%10];
 191   2      
 192   2            from[LED_FDTimeLeft_COM1]=Number[MyEeprom.EepromTestArea[3]/100]; //3
 193   2            from[LED_FDTimeLeft_COM2]=Number[MyEeprom.EepromTestArea[3]%100/10];
 194   2            from[LED_FDTimeLeft_COM3]=Number[MyEeprom.EepromTestArea[3]%10];
 195   2      #endif
 196   2            break;
 197   2          case 'D':
 198   2      #if TestEeprom==TRUE
 199   2            //显示总共写入了多少次
 200   2            from[LED_RealTemp_COM1]=Number[MyEeprom.EepromTestWriteCount/1000000];
 201   2            from[LED_RealTemp_COM2]=Number[MyEeprom.EepromTestWriteCount%1000000/100000]&SEG_DPOFF; //1
 202   2            from[LED_RealTemp_COM3]=Number[MyEeprom.EepromTestWriteCount%100000/10000];
 203   2            from[LED_RealTemp_COM4]=Number[MyEeprom.EepromTestWriteCount%10000/1000];
 204   2      
 205   2      
 206   2            from[LED_RealHumidity_COM1]=Number[MyEeprom.EepromTestWriteCount%1000/100];
 207   2            from[LED_RealHumidity_COM2]=Number[MyEeprom.EepromTestWriteCount%100/10];
 208   2      
 209   2            from[LED_FDTimeLeft_COM1]=Number[MyEeprom.EepromTestWriteCount%10];
 210   2            from[LED_FDTimeLeft_COM2]=ALL_SEG_OFF;
 211   2            from[LED_FDTimeLeft_COM3]=ALL_SEG_OFF;
 212   2      #endif
 213   2            break;
 214   2      
 215   2          default:
 216   2            break;
 217   2        }
 218   1      }
 219          
 220          #endif
 221          
 222          
 223          
 224          
 225          /*****************************************************************************
 226           Prototype    : MyEepromSaveAllDataUserHandle
 227           Description  : 用户接口,程序自动选择的当前区域中保存用户的所有的数据
 228                          注意:
 229                              1 此接口必须写入所有需要保存的数据
 230                              2 此接口处单个字节写调用EepromWriteByte()函数
 231           Input        : unsigned char writeOnWhichArea 当前保存数据的区域
 232           Output       : None
 233           Return Value :
 234           Calls        :
 235           Called By    :
 236          
C51 COMPILER V9.56.0.0   MYEEPROM                                                          07/09/2021 14:29:49 PAGE 5   

 237            History        :
 238            1.Date         : 2021/7/6
 239              Author       : Dragon8814
 240              Modification : Created function
 241          
 242          ****************************************************************************/
 243          
 244          void MyEepromSaveAllDataUserHandle ( unsigned char writeOnWhichArea )
 245          {
 246   1      
 247   1        /***************************用户自定义段没有需要不添加*************************/
 248   1            unsigned int xdata setTemp;
 249   1            unsigned char xdata setHumidity, fd_Time;
 250   1        //只有在DIY模式下需要备份 
 251   1        //其他模式需要备份再写入,避免下次运行DIY模式时参数出错
 252   1        if ( SetData.FH_Mode != 9 )
 253   1        {
 254   2          setTemp = SetData.SetTemp; //备份当前运行
 255   2          setHumidity = SetData.SetHumidity;
 256   2          fd_Time = SetData.FD_Time;
 257   2          SetData.SetHumidity = SetData.SetHumidityBuf; //保存原始数据，
 258   2          SetData.SetTemp = SetData.SetTempBuf;
 259   2          SetData.FD_Time = SetData.FD_TimeBuf;
 260   2      
 261   2          RunData.WorkTimeBuf = RunData.WorkTime_Second;
 262   2        }
 263   1        else
 264   1        {
 265   2          //是DIY 需要更新本次数据，避免下次切换其他模式时还是保存旧的数据
 266   2          SetData.FD_TimeBuf = SetData.FD_Time;
 267   2          SetData.SetTempBuf = SetData.SetTemp;
 268   2          SetData.SetHumidityBuf = SetData.SetHumidity;
 269   2      
 270   2          RunData.WorkTimeBuf = RunData.WorkTime_Second;
 271   2        }
 272   1        /*********************************END********************************************/
 273   1      
 274   1      
 275   1      
 276   1      
 277   1      
 278   1      
 279   1        CLR_WDT;
 280   1          /*****************************用户必须添加段，必须加入所有需要保存的数据*************************/
 281   1        EepromWriteByte ( EepromStrogeValue*2* writeOnWhichArea +FH_ModeAddr*2, SetData.FH_Mode );
 282   1        //写入设置温度
 283   1        EepromWriteByte ( EepromStrogeValue*2* writeOnWhichArea +SetTempAddr_L*2,SetData.SetTemp );
 284   1        EepromWriteByte ( EepromStrogeValue* 2* writeOnWhichArea +SetTempAddr_H*2, SetData.SetTemp >> 8 );
 285   1      
 286   1        EepromWriteByte ( EepromStrogeValue* 2* writeOnWhichArea + SetHumidityAddr*2, SetData.SetHumidity );
 287   1        EepromWriteByte (  EepromStrogeValue* 2* writeOnWhichArea +FD_TimeAddr*2, SetData.FD_Time );
 288   1      
 289   1        CLR_WDT;
 290   1        EepromWriteByte (  EepromStrogeValue* 2* writeOnWhichArea +SystemStartFlagAddr*2, ( unsigned char ) Syste
             -mStart_Flag );
 291   1        EepromWriteByte (  EepromStrogeValue* 2* writeOnWhichArea +WorkTimeAddr_L*2, RunData.WorkTime_Second & 0x
             -00ff );
 292   1        EepromWriteByte (  EepromStrogeValue* 2* writeOnWhichArea +WorkTimeAddr_H*2, RunData.WorkTime_Second >> 8
             - );
 293   1        EepromWriteByte (  EepromStrogeValue* 2* writeOnWhichArea +FD_CountAdd_L*2, RunData.FD_Count & 0x00ff );
 294   1        EepromWriteByte (  EepromStrogeValue* 2* writeOnWhichArea +FD_CountAdd_H*2, RunData.FD_Count >> 8 );
 295   1      
C51 COMPILER V9.56.0.0   MYEEPROM                                                          07/09/2021 14:29:49 PAGE 6   

 296   1      #if TestEeprom==TRUE //测试用
 297   1        {
 298   2          //测试时这几个地址更改为保存总写入次数 ,也可以自定义其他地址
 299   2          //MyEeprom.EepromTestWriteCount=tt;
 300   2          EepromWriteByte (  EepromStrogeValue* 2* writeOnWhichArea +CS_CountAddr_L*2,  MyEeprom.EepromTestWriteCo
             -unt & 0x000000ff );
 301   2          EepromWriteByte (  EepromStrogeValue* 2* writeOnWhichArea +CS_CountAddr_H*2, ( MyEeprom.EepromTestWriteC
             -ount>>8 ) & 0x000000ff );
 302   2          CLR_WDT;
 303   2          EepromWriteByte (  EepromStrogeValue* 2* writeOnWhichArea +SetStableDukAddr_L*2, ( MyEeprom.EepromTestWr
             -iteCount>>16 ) & 0x000000ff );
 304   2          EepromWriteByte (  EepromStrogeValue* 2* writeOnWhichArea +SetStableDukAddr_H*2, ( MyEeprom.EepromTestWr
             -iteCount>>24 ) );
 305   2      
 306   2        }
 307   1      #else
              
                EepromWriteByte (  EepromStrogeValue* 2* writeOnWhichArea +CS_CountAddr_L*2, RunData.CS_Count & 0x00ff );
                EepromWriteByte (  EepromStrogeValue* 2* writeOnWhichArea +CS_CountAddr_H*2, RunData.CS_Count >> 8 );
                CLR_WDT;
                EepromWriteByte (  EepromStrogeValue* 2* writeOnWhichArea +SetStableDukAddr_L*2, RunData.DukBuf_H & 0x00f
             -f );
                EepromWriteByte (  EepromStrogeValue* 2* writeOnWhichArea +SetStableDukAddr_H*2, RunData.DukBuf_H >> 8 );
              #endif
 315   1         /*********************************END********************************************/
 316   1      
 317   1      
 318   1      
 319   1      
 320   1      
 321   1      
 322   1      
 323   1         /***************************用户自定义段没有需要不添加*************************/
 324   1        //用户自定义数据恢复
 325   1        if ( SetData.FH_Mode != 9 )
 326   1        {
 327   2          SetData.SetHumidity = setHumidity; //恢复
 328   2          SetData.SetTemp = setTemp;
 329   2          SetData.FD_Time = fd_Time;
 330   2        }
 331   1        /***************************用户自定义段没有需要不添加*************************/
 332   1      
 333   1      }
 334          
 335          
 336          
 337          
 338          /*****************************************************************************
 339           Prototype    : MyEepromRead
 340           Description  : 根据地址读取单个数据 用户调用
 341           Input        : unsigned char addr  
 342           Output       : None
 343           Return Value : unsigned
 344           Calls        : 
 345           Called By    : 
 346           
 347            History        :
 348            1.Date         : 2021/7/6
 349              Author       : Dragon8814
 350              Modification : Created function
 351          
 352          *****************************************************************************/
C51 COMPILER V9.56.0.0   MYEEPROM                                                          07/09/2021 14:29:49 PAGE 7   

 353          unsigned char MyEepromRead(unsigned char addr)
 354          {
 355   1      
 356   1         return EepromRead ( addr );
 357   1      }
 358          
 359          
 360          
 361          
 362          
 363          
 364          /*****************************************************************************
 365           Prototype    : ReadSameDataFromEeprom
 366           Description  : 用户自定义，在Eeprom读取一些数据
 367           Input        : None
 368           Output       : None
 369           Return Value :
 370           Calls        :
 371           Called By    :
 372          
 373            History        :
 374            1.Date         : 2021/7/6
 375              Author       : Dragon8814
 376              Modification : Created function
 377          
 378          *****************************************************************************/
 379          
 380          void ReadSameDataFromEeprom()
 381          {
 382   1          #if TestEeprom==TRUE
 383   1             if(MyEeprom.EepromTestWriteCount==0) //上电读取擦除次数
 384   1             MyEepromTestHandle ( FALSE,'A' );
 385   1          #endif
 386   1      
 387   1        SetData.FH_Mode=MyEepromRead ( FH_ModeAddr );
 388   1      
 389   1        SetData.FD_Time=MyEepromRead (  FD_TimeAddr );
 390   1      
 391   1        SetData.SetTemp=MyEepromRead (  SetTempAddr_L );
 392   1        SetData.SetTemp+= ( ( unsigned int ) MyEepromRead ( SetTempAddr_H ) <<8 );
 393   1        SetData.SetHumidity= MyEepromRead ( SetHumidityAddr );
 394   1        SetData.SetHumidityBuf=SetData.SetHumidity;
 395   1        SystemStart_Flag= ( bit ) MyEepromRead ( SystemStartFlagAddr );
 396   1        RunData.WorkTime_Second=MyEepromRead ( WorkTimeAddr_L )+ ( ( unsigned int ) MyEepromRead ( WorkTimeAddr_H
             - ) <<8 ) ;
 397   1        RunData.WorkTimeBuf=RunData.WorkTime_Second;
 398   1        RunData.FD_Count=MyEepromRead (  FD_CountAdd_L );
 399   1        RunData.FD_Count+= ( ( unsigned int ) MyEepromRead ( FD_CountAdd_H ) <<8 );
 400   1        RunData.CS_Count=MyEepromRead ( CS_CountAddr_L )+ ( ( unsigned int ) MyEepromRead ( CS_CountAddr_H ) <<8 
             -) ;
 401   1      
 402   1      
 403   1      }
 404          
 405          
 406          
 407          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1372    ----
   CONSTANT SIZE    =   ----    ----
C51 COMPILER V9.56.0.0   MYEEPROM                                                          07/09/2021 14:29:49 PAGE 8   

   XDATA SIZE       =     13       4
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       4
   IDATA SIZE       =   ----       2
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
