C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          07/10/2021 20:04:07 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN_FHQ
OBJECT MODULE PLACED IN MAIN_FHQ.OBJ
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE MAIN_FHQ.c OPTIMIZE(9,SIZE) BROWSE INCDIR(.\Drivers) DEBUG OBJECTEXTEND 
                    -TABS(2)

line level    source

   1          
   2          
   3          
   4          /**************************** MyEeprom 模块概述**********************************
   5          *********************************************************************************
   6              TM52Fxx系列芯片 内部EEPROM擦写次数为最小大于5万次,即单个地址的擦写次数是有限的
   7           随着擦写次数的增加每次擦写的时间会有所延长，虽然对于一般不需要经常操作EEPROM的应
   8           用5-10万的擦写次数完全可以满足整个芯片使用周期，但有些应用需要更加频繁的保存/读取
   9           数据则需要芯片能够提供足够多的擦写次数。本DEMO主要为了有以上需要的朋友们提供一个很
  10           好的解决方案.
  11              DEMO的大致原理就是在芯片提供的整个EEPROM空间内，根据用户需要保存数据的大小,自动
  12           分配N个区域,根据数据写入的次数动态地把用户数据保存在这些区域中，在芯片使用周期内确
  13           保整个EEPROM空间使用率得到很好的平衡。理论上可以就达到了延长芯片EEPROM的使用寿命的
  14           目的，使用寿命将延长至原来的xN(区域)倍。经压力测试每秒擦写20-30次保存15字节数据擦写
  15           次数已经超过18万次多，数据没有发现异常.
  16          
  17           模块配置使用步骤----MyEeprom.h头文件
  18               1：根据提示修改以下宏定义     
  19                  #define ChipEepromRamCP  256     //芯片EepromRam的容量大小
  20                  #define EepromStartAddr  0XEE00   //这个芯片EEPROM物理内存中起始地址
  21                  #define TM52FE8276_TotalEeprom  128  //这个芯片总共可以使用的EEPROM字节，TM52f82xx芯片偶地址有效
  22          
  23               2：在枚举项@AllEepromAddr加入你需要保存数据的地址名称
  24                  注意枚举中前后两个项不能更改
  25          
  26               3：如果需要调试或其他测试，设置宏定义 TestEeprom  为TRUE  
  27               
  28           模块配置使用步骤----MyEeprom.c文件
  29               1：在工程初始化调用函数 MyEepromInit()
  30          
  31               2：根据提示修改此接口函数内部MyEepromSaveAllDataUserHandle (  )
  32          
  33               3：单个数据写调用--MyEepromWrite ( unsigned int,unsigned char ,unsigned char )
  34                  单个数据读调用--unsigned char MyEepromRead(unsigned char)
  35          
  36                  测试时接口--    MyEepromTestHandle ( char* from,unsigned char flag )
  37          
  38          
  39           其他：暂时只测试了十速TM52FE8273芯片，根据数据手册其他TM52FEXX系列应该也是可以通用的
  40                 移植到到其他只需需该修改部分代码，后续有时间继续更新
  41           
  42          ******************************************************************************
  43          
  44          ******************************************************************************/
  45          
  46          
  47          
  48          #include "TM52F82XX_Eeprom.h"
  49          #include "MyEeprom.h"
  50          
  51          #include "DEFINE.H"
  52          
  53          
  54          #include "Uart.h"
C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          07/10/2021 20:04:07 PAGE 2   

  55          
  56          #include "Delay.h"
  57          #include "LED.h"
  58          
  59          
  60          #include  <intrins.h>
  61          
  62          #include <REGtenxTM52FE8276.h>
  63          
  64          
  65          
  66          
  67          void     Timer0_Init();
  68          void         SetLEDDisplay();
  69          
  70          
  71          
  72          /* 快时钟系统主频为 14.7456M
  73           */
  74          void bsp_clock_init()
  75          {
  76   1        SELFCK = 0;      //切换到慢时钟
  77   1        SYSCLOCK_DIV_1;   //div 1时钟分频
  78   1        Delay30us();
  79   1        SELFCK = 1;     //切换到快时钟
  80   1      }
  81          
  82          void SystemInit()
  83          {
  84   1        unsigned char t;
  85   1      
  86   1        for ( t=0; t<10; t++ )
  87   1        {
  88   2          Delay10Ms();
  89   2        }
  90   1        bsp_clock_init();
  91   1        MyEepromInit();
  92   1        UartInit();
  93   1        Timer0_Init();
  94   1      
  95   1        #if TestEeprom==TRUE
  96   1        MyEeprom.EepromTestWriteCount=0;
  97   1          #endif
  98   1        ReadSameDataFromEeprom();
  99   1      
 100   1        
 101   1        WDTPSC0;//WDT 480MS
 102   1        WDT_RUN_FAST_DIS_ILDE;
 103   1      
 104   1        EA=1;
 105   1      }
 106          
 107          void ClearXRAM ( void )
 108          {
 109   1        unsigned char xdata* data l_p_ucXdata;
 110   1        unsigned int idata i;
 111   1        l_p_ucXdata = 0xfd00;
 112   1        for ( i = 0; i < 768; i++ )
 113   1        {
 114   2          * ( l_p_ucXdata++ ) = 0x00;
 115   2        }
 116   1      }
C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          07/10/2021 20:04:07 PAGE 3   

 117          
 118          
 119          #if TestEeprom==TRUE
 120          //需要用户自行加入LED显示模块
 121          void SetLEDDisplay()
 122          {
 123   1      
 124   1          //eeprom测试用
 125   1        if ( RunData.WorkCount_60s<20 )
 126   1        {
 127   2          MyEepromTestHandle  ( ( char* ) LEDShow,'C' ); //LED显示相应区域
 128   2        }
 129   1        else
 130   1        {
 131   2          MyEepromTestHandle ( ( char* ) LEDShow,'D' );//LED显示总写入次数
 132   2        }
 133   1      }
 134          
 135          #endif
 136          
 137          #if TestEeprom
 138          unsigned char GetHex(unsigned char dat )
 139          {
 140   1        if(dat==0)
 141   1          return 0x30;
 142   1       if(dat<10)
 143   1          return dat+0x30;
 144   1        else
 145   1          return dat+0x37;
 146   1          
 147   1      }
 148          
 149          #endif
 150          
 151          
 152          void SendToUart()
 153          {
 154   1         #if TestEeprom==TRUE
 155   1         /***********************************************************
 156   1           每1S发送一次
 157   1           注意因为过快的写入和读取时间导致有些参数始终没有变化的问题
 158   1         ************************************************************/
 159   1        if ( ( RunData.SendDataToUartCount >=1)  ) 
 160   1        {
 161   2      
 162   2          unsigned char xdata send[100];
 163   2          unsigned char  t=0;
 164   2          MyEepromTestHandle ( FALSE,'A' );
 165   2      
 166   2          ReadSameDataFromEeprom();
 167   2      
 168   2          send[t++]=  'M' ;
 169   2          send[t++]=  'y' ;
 170   2          send[t++]= 'E' ;
 171   2          send[t++]=  'e' ;
 172   2          send[t++]=  'p' ;
 173   2          send[t++]=  'r' ;
 174   2          send[t++]= 'o' ;
 175   2          send[t++]=  'm' ;
 176   2          send[t++]= 'T' ;
 177   2          send[t++]=  'e' ;
 178   2          send[t++]=  's' ;
C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          07/10/2021 20:04:07 PAGE 4   

 179   2          send[t++]=  't' ;
 180   2          send[t++]=  ':' ;
 181   2          send[t++]=  '\r' ;
 182   2          send[t++]=  '\n' ;
 183   2      
 184   2          send[t++]=  '[' ;
 185   2          send[t++]=  'T' ;
 186   2          send[t++]=  'i' ;
 187   2          send[t++]=  'm' ;
 188   2          send[t++]=  'e' ;
 189   2          send[t++]=  ':' ;
 190   2          send[t++]=  ( RunData.WorkTime_Second/10000+0x30 );
 191   2          send[t++]=  ( RunData.WorkTime_Second%10000/1000+0x30 );
 192   2          send[t++]=  ( RunData.WorkTime_Second%1000/100+0x30 );
 193   2          send[t++]=  ( RunData.WorkTime_Second%100/10+0x30 );
 194   2          send[t++]=  ( RunData.WorkTime_Second%10+0x30 );
 195   2          send[t++]=  ']' ;
 196   2          send[t++]=  '-' ;
 197   2      
 198   2          send[t++]=  '[' ;
 199   2          send[t++]=  GetHex(RunData.FD_Count>>12);
 200   2          send[t++]=  GetHex((RunData.FD_Count>>8)&0x000f);
 201   2          send[t++]=  GetHex((RunData.FD_Count>>4)&0x000f);
 202   2          send[t++]=  GetHex(RunData.FD_Count&0x000f);
 203   2          send[t++]=   ']' ;
 204   2          send[t++]=  '-' ;
 205   2      
 206   2              send[t++]=  '[' ;
 207   2          send[t++]=  GetHex( SetData.FH_Mode>>8 );
 208   2          send[t++]=  GetHex( SetData.FH_Mode&0x0f);
 209   2          send[t++]=  ']' ;
 210   2          send[t++]=  '-' ;
 211   2          
 212   2          send[t++]= '[' ;
 213   2          send[t++]= GetHex( SetData.SetTemp>>12);
 214   2          send[t++]= GetHex( (SetData.SetTemp>>8)&0x000f);
 215   2          send[t++]= GetHex( (SetData.SetTemp>>4)&0x000f );
 216   2          send[t++]= GetHex( SetData.SetTemp&0x000f);
 217   2          send[t++]=  ']' ;
 218   2          send[t++]=  '-' ;
 219   2      
 220   2          send[t++]= '[' ;
 221   2          send[t++]= GetHex( SetData.SetHumidity>>8 );
 222   2          send[t++]= GetHex( SetData.SetHumidity&0x0f );
 223   2          send[t++]= ']' ;
 224   2          send[t++]=  '-' ;
 225   2      
 226   2      
 227   2      
 228   2          send[t++]=  '[' ;
 229   2          send[t++]=  ( MyEeprom.EepromTestWriteCount /10000000+0x30 );
 230   2          send[t++]=  ( MyEeprom.EepromTestWriteCount %10000000/1000000+0x30 );
 231   2          send[t++]=  ( MyEeprom.EepromTestWriteCount %1000000/100000+0x30 );
 232   2          send[t++]=  ( MyEeprom.EepromTestWriteCount %100000/10000+0x30 );
 233   2          send[t++]=  ( MyEeprom.EepromTestWriteCount %10000/1000+0x30 );
 234   2          send[t++]=  ( MyEeprom.EepromTestWriteCount %1000/100+0x30 );
 235   2          send[t++]=  ( MyEeprom.EepromTestWriteCount %100/10+0x30 );
 236   2          send[t++]=  ( MyEeprom.EepromTestWriteCount %10+0x30 );
 237   2          send[t++]=  ']' ;
 238   2          
 239   2      
 240   2          send[t++]= '\r' ;
C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          07/10/2021 20:04:07 PAGE 5   

 241   2          send[t++]=  '\n' ;
 242   2          send[t++]= '\r' ;
 243   2          send[t++]=  '\n' ;
 244   2          UartSendArray ( send, t );
 245   2      
 246   2          RunData.SendDataToUartCount=0;
 247   2        }
 248   1      
 249   1         #else
                  UartSendArray ( "---\r\n", 5 );
                 #endif
 252   1      }
 253          
 254          
 255          
 256          
 257          void main ()
 258          {
 259   1      
 260   1        bsp_clock_init();  //快时钟系统主频为 14.7456M/2 = 7.3728M
 261   1        ClearXRAM();
 262   1        SystemInit();
 263   1      
 264   1      
 265   1        P0OE|= ( 1<<7 );
 266   1          P0_7=1;
 267   1      
 268   1        while ( 1 )
 269   1        {
 270   2        
 271   2              if(RunData.WorkCount_60s%5==0)
 272   2               P0_7=1;
 273   2               else if(RunData.WorkCount_60s%7==0)
 274   2               P0_7=0;
 275   2               
 276   2      #if TestEeprom==TRUE
 277   2              //EEPROM写入测试
 278   2          MyEepromTestHandle ((char*)(&RunData.WorkCount_10ms) ,'B' ); 
 279   2          //写入LED缓冲区显示查看
 280   2          SetLEDDisplay(); 
 281   2      #endif    
 282   2      
 283   2          //数据发送到串口查看
 284   2          SendToUart();
 285   2      
 286   2        }
 287   1      }
 288          
 289          
 290          
 291          
 292          
 293          
 294          void ISR_TIMER0() interrupt 1  //2ms
 295          
 296          {
 297   1      
 298   1      
 299   1        static unsigned char Count_10Ms;
 300   1      
 301   1        TH0 = 0xc6; // timer0 高字节数据
 302   1        TL0 = 0x66+16;  // timer0 低字节数据
C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          07/10/2021 20:04:07 PAGE 6   

 303   1      
 304   1        CLR_WDT;
 305   1      
 306   1        //Uart_SetTimeOut();
 307   1      
 308   1        Count_10Ms++;
 309   1        if ( Count_10Ms>=5 )
 310   1        {
 311   2          Count_10Ms=0;
 312   2          RunData.WorkCount_10ms++;
 313   2          RunData.WorkCount_1s++;
 314   2          RunData.WorkTime_Second++;
 315   2          if ( RunData.WorkCount_1s>=100 )
 316   2          {
 317   3            RunData.SendDataToUartCount++;
 318   3            RunData.WorkCount_1s=0;
 319   3            RunData.WorkCount_60s++;
 320   3            //RunData.WorkTime_Second++;
 321   3            if ( RunData.WorkCount_60s>=60 )
 322   3            {
 323   4              RunData.WorkCount_60s=0;
 324   4            }
 325   3          }
 326   2      
 327   2        }
 328   1      
 329   1      
 330   1      }
 331          
 332          
 333          
 334          
 335          
 336          
 337          void Timer0_Init()
 338          {
 339   1      
 340   1        TMOD = ( ( TMOD&~0X03 ) |T0_Mode1 ); //模式1 16位定时器/计数器(TMOD &~ TMOD_TMOD0_MASK)|1<<TMOD_TMOD0_POS
             -;
 341   1      
 342   1        TH0 = 0xc6;    // timer0 高字节数据
 343   1        TL0 = 0x66;    // timer0 低字节数据
 344   1        ET0 = 1;
 345   1        TF0 = 0;
 346   1        TR0 =1 ;
 347   1      }
 348          
 349          
 350          
 351          
 352          
 353          
 354          
 355          
 356          
 357          
 358          
 359          
 360          
 361          
 362          
 363          
C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          07/10/2021 20:04:07 PAGE 7   

 364          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1068    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----     100
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1       2
   IDATA SIZE       =   ----       2
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
