C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          07/10/2021 09:48:14 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN_FHQ
OBJECT MODULE PLACED IN MAIN_FHQ.OBJ
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE MAIN_FHQ.c OPTIMIZE(9,SIZE) BROWSE INCDIR(.\Drivers) DEBUG OBJECTEXTEND 
                    -TABS(2)

line level    source

   1          
   2          
   3          
   4          /**************************** MyEeprom 模块概述**********************************
   5          *********************************************************************************
   6              TM52Fxx系列芯片 内部EEPROM擦写次数为最小大于5万次,即单个地址的擦写次数是有限的
   7           随着擦写次数的增加每次擦写的时间会有所延长，虽然对于一般不需要经常操作EEPROM的应
   8           用5-10万的擦写次数完全可以满足整个芯片使用周期，但有些应用需要更加频繁的保存/读取
   9           数据则需要芯片能够提供足够多的擦写次数。本DEMO主要为了有以上需要的朋友们提供一个很
  10           好的解决方案.
  11              DEMO的大致原理就是在芯片提供的整个EEPROM空间内，根据用户需要保存数据的大小,自动
  12           分配N个区域,根据数据写入的次数动态地把用户数据保存在这些区域中，在芯片使用周期内确
  13           保整个EEPROM空间使用率得到很好的平衡。理论上可以就达到了延长芯片EEPROM的使用寿命的
  14           目的，使用寿命将延长至原来的xN(区域)倍。经压力测试每秒擦写20-30次保存15字节数据擦写
  15           次数已经超过18万次多，数据没有发现异常.
  16          
  17           模块配置使用步骤----MyEeprom.h头文件
  18               1：根据提示修改以下宏定义     
  19                  #define ChipEepromRamCP  256     //芯片EepromRam的容量大小
  20                  #define EepromStartAddr  0XEE00   //这个芯片EEPROM物理内存中起始地址
  21                  #define TM52FE8276_TotalEeprom  128  //这个芯片总共可以使用的EEPROM字节，TM52f82xx芯片偶地址有效
  22          
  23               2：在枚举项@AllEepromAddr加入你需要保存数据的地址名称
  24                  注意枚举中前后两个项不能更改
  25          
  26               3：如果需要调试或其他测试，设置宏定义 TestEeprom  为TRUE  
  27               
  28           模块配置使用步骤----MyEeprom.c文件
  29               1：在工程初始化调用函数 MyEepromInit()
  30          
  31               2：根据提示修改此接口函数内部MyEepromSaveAllDataUserHandle (  )
  32          
  33               3：单个数据写调用--MyEepromWrite ( unsigned int,unsigned char ,unsigned char )
  34                  单个数据读调用--unsigned char MyEepromRead(unsigned char)
  35          
  36                  测试时接口--    MyEepromTestHandle ( char* from,unsigned char flag )
  37           
  38          
  39           ******************************************************************************
  40          
  41          ******************************************************************************/
  42          
  43          
  44          
  45          #include "TM52F82XX_Eeprom.h"
  46          #include "MyEeprom.h"
  47          
  48          #include "DEFINE.H"
  49          
  50          
  51          #include "Uart.h"
  52          
  53          #include "Delay.h"
  54          #include "LED.h"
C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          07/10/2021 09:48:14 PAGE 2   

  55          
  56          
  57          #include  <intrins.h>
  58          
  59          #include <REGtenxTM52FE8276.h>
  60          
  61          
  62          
  63          
  64          void     Timer0_Init();
  65          void         SetLEDDisplay();
  66          
  67          
  68          
  69          /* 快时钟系统主频为 14.7456M
  70           */
  71          void bsp_clock_init()
  72          {
  73   1        SELFCK = 0;      //切换到慢时钟
  74   1        SYSCLOCK_DIV_1;   //div 1时钟分频
  75   1        Delay30us();
  76   1        SELFCK = 1;     //切换到快时钟
  77   1      }
  78          
  79          void SystemInit()
  80          {
  81   1        unsigned char t;
  82   1      
  83   1        for ( t=0; t<10; t++ )
  84   1        {
  85   2          Delay10Ms();
  86   2        }
  87   1        bsp_clock_init();
  88   1        MyEepromInit();
  89   1        UartInit();
  90   1        Timer0_Init();
  91   1      
  92   1        #if TestEeprom==TRUE
  93   1        MyEeprom.EepromTestWriteCount=0;
  94   1          #endif
  95   1        ReadSameDataFromEeprom();
  96   1      
  97   1        
  98   1        WDTPSC0;//WDT 480MS
  99   1        WDT_RUN_FAST_DIS_ILDE;
 100   1      
 101   1        EA=1;
 102   1      }
 103          
 104          void ClearXRAM ( void )
 105          {
 106   1        unsigned char xdata* data l_p_ucXdata;
 107   1        unsigned int idata i;
 108   1        l_p_ucXdata = 0xfd00;
 109   1        for ( i = 0; i < 768; i++ )
 110   1        {
 111   2          * ( l_p_ucXdata++ ) = 0x00;
 112   2        }
 113   1      }
 114          
 115          
 116          #if TestEeprom==TRUE
C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          07/10/2021 09:48:14 PAGE 3   

 117          //需要用户自行加入LED显示模块
 118          void SetLEDDisplay()
 119          {
 120   1      
 121   1          //eeprom测试用
 122   1        if ( RunData.WorkCount_60s<20 )
 123   1        {
 124   2          MyEepromTestHandle  ( ( char* ) LEDShow,'C' ); //LED显示相应区域
 125   2        }
 126   1        else
 127   1        {
 128   2          MyEepromTestHandle ( ( char* ) LEDShow,'D' );//LED显示总写入次数
 129   2        }
 130   1      }
 131          
 132          #endif
 133          
 134          #if TestEeprom
 135          unsigned char GetHex(unsigned char dat )
 136          {
 137   1        if(dat==0)
 138   1          return 0x30;
 139   1       if(dat<10)
 140   1          return dat+0x30;
 141   1        else
 142   1          return dat+0x37;
 143   1          
 144   1      }
 145          
 146          #endif
 147          
 148          
 149          void SendToUart()
 150          {
 151   1         #if TestEeprom==TRUE
 152   1         /***********************************************************
 153   1           每1S发送一次
 154   1           注意因为过快的写入和读取时间导致有些参数始终没有变化的问题
 155   1         ************************************************************/
 156   1        if ( ( RunData.SendDataToUartCount >=1)  ) 
 157   1        {
 158   2      
 159   2          unsigned char xdata send[100];
 160   2          unsigned char  t=0;
 161   2          MyEepromTestHandle ( FALSE,'A' );
 162   2      
 163   2          ReadSameDataFromEeprom();
 164   2      
 165   2          send[t++]=  'M' ;
 166   2          send[t++]=  'y' ;
 167   2          send[t++]= 'E' ;
 168   2          send[t++]=  'e' ;
 169   2          send[t++]=  'p' ;
 170   2          send[t++]=  'r' ;
 171   2          send[t++]= 'o' ;
 172   2          send[t++]=  'm' ;
 173   2          send[t++]= 'T' ;
 174   2          send[t++]=  'e' ;
 175   2          send[t++]=  's' ;
 176   2          send[t++]=  't' ;
 177   2          send[t++]=  ':' ;
 178   2          send[t++]=  '\r' ;
C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          07/10/2021 09:48:14 PAGE 4   

 179   2          send[t++]=  '\n' ;
 180   2      
 181   2          send[t++]=  '[' ;
 182   2          send[t++]=  'T' ;
 183   2          send[t++]=  'i' ;
 184   2          send[t++]=  'm' ;
 185   2          send[t++]=  'e' ;
 186   2          send[t++]=  ':' ;
 187   2          send[t++]=  ( RunData.WorkTime_Second/10000+0x30 );
 188   2          send[t++]=  ( RunData.WorkTime_Second%10000/1000+0x30 );
 189   2          send[t++]=  ( RunData.WorkTime_Second%1000/100+0x30 );
 190   2          send[t++]=  ( RunData.WorkTime_Second%100/10+0x30 );
 191   2          send[t++]=  ( RunData.WorkTime_Second%10+0x30 );
 192   2          send[t++]=  ']' ;
 193   2          send[t++]=  '-' ;
 194   2      
 195   2          send[t++]=  '[' ;
 196   2          send[t++]=  GetHex(RunData.FD_Count>>12);
 197   2          send[t++]=  GetHex((RunData.FD_Count>>8)&0x000f);
 198   2          send[t++]=  GetHex((RunData.FD_Count>>4)&0x000f);
 199   2          send[t++]=  GetHex(RunData.FD_Count&0x000f);
 200   2          send[t++]=   ']' ;
 201   2          send[t++]=  '-' ;
 202   2      
 203   2              send[t++]=  '[' ;
 204   2          send[t++]=  GetHex( SetData.FH_Mode>>8 );
 205   2          send[t++]=  GetHex( SetData.FH_Mode&0x0f);
 206   2          send[t++]=  ']' ;
 207   2          send[t++]=  '-' ;
 208   2          
 209   2          send[t++]= '[' ;
 210   2          send[t++]= GetHex( SetData.SetTemp>>12);
 211   2          send[t++]= GetHex( (SetData.SetTemp>>8)&0x000f);
 212   2          send[t++]= GetHex( (SetData.SetTemp>>4)&0x000f );
 213   2          send[t++]= GetHex( SetData.SetTemp&0x000f);
 214   2          send[t++]=  ']' ;
 215   2          send[t++]=  '-' ;
 216   2      
 217   2          send[t++]= '[' ;
 218   2          send[t++]= GetHex( SetData.SetHumidity>>8 );
 219   2          send[t++]= GetHex( SetData.SetHumidity&0x0f );
 220   2          send[t++]= ']' ;
 221   2          send[t++]=  '-' ;
 222   2      
 223   2      
 224   2      
 225   2          send[t++]=  '[' ;
 226   2          send[t++]=  ( MyEeprom.EepromTestWriteCount /10000000+0x30 );
 227   2          send[t++]=  ( MyEeprom.EepromTestWriteCount %10000000/1000000+0x30 );
 228   2          send[t++]=  ( MyEeprom.EepromTestWriteCount %1000000/100000+0x30 );
 229   2          send[t++]=  ( MyEeprom.EepromTestWriteCount %100000/10000+0x30 );
 230   2          send[t++]=  ( MyEeprom.EepromTestWriteCount %10000/1000+0x30 );
 231   2          send[t++]=  ( MyEeprom.EepromTestWriteCount %1000/100+0x30 );
 232   2          send[t++]=  ( MyEeprom.EepromTestWriteCount %100/10+0x30 );
 233   2          send[t++]=  ( MyEeprom.EepromTestWriteCount %10+0x30 );
 234   2          send[t++]=  ']' ;
 235   2          
 236   2      
 237   2          send[t++]= '\r' ;
 238   2          send[t++]=  '\n' ;
 239   2          send[t++]= '\r' ;
 240   2          send[t++]=  '\n' ;
C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          07/10/2021 09:48:14 PAGE 5   

 241   2          UartSendArray ( send, t );
 242   2      
 243   2          RunData.SendDataToUartCount=0;
 244   2        }
 245   1      
 246   1         #else
                  UartSendArray ( "---\r\n", 5 );
                 #endif
 249   1      }
 250          
 251          
 252          
 253          
 254          void main ()
 255          {
 256   1      
 257   1        bsp_clock_init();  //快时钟系统主频为 14.7456M/2 = 7.3728M
 258   1        ClearXRAM();
 259   1        SystemInit();
 260   1      
 261   1      
 262   1        P0OE|= ( 1<<7 );
 263   1          P0_7=1;
 264   1      
 265   1        while ( 1 )
 266   1        {
 267   2        
 268   2              if(RunData.WorkCount_60s%5==0)
 269   2               P0_7=1;
 270   2               else if(RunData.WorkCount_60s%7==0)
 271   2               P0_7=0;
 272   2               
 273   2      #if TestEeprom==TRUE
 274   2              //EEPROM写入测试
 275   2          MyEepromTestHandle ((char*)(&RunData.WorkCount_10ms) ,'B' ); 
 276   2          //写入LED缓冲区显示查看
 277   2          SetLEDDisplay(); 
 278   2      #endif    
 279   2      
 280   2          //数据发送到串口查看
 281   2          SendToUart();
 282   2      
 283   2        }
 284   1      }
 285          
 286          
 287          
 288          
 289          
 290          
 291          void ISR_TIMER0() interrupt 1  //2ms
 292          
 293          {
 294   1      
 295   1      
 296   1        static unsigned char Count_10Ms;
 297   1      
 298   1        TH0 = 0xc6; // timer0 高字节数据
 299   1        TL0 = 0x66+16;  // timer0 低字节数据
 300   1      
 301   1        CLR_WDT;
 302   1      
C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          07/10/2021 09:48:14 PAGE 6   

 303   1        //Uart_SetTimeOut();
 304   1      
 305   1        Count_10Ms++;
 306   1        if ( Count_10Ms>=5 )
 307   1        {
 308   2          Count_10Ms=0;
 309   2          RunData.WorkCount_10ms++;
 310   2          RunData.WorkCount_1s++;
 311   2          RunData.WorkTime_Second++;
 312   2          if ( RunData.WorkCount_1s>=100 )
 313   2          {
 314   3            RunData.SendDataToUartCount++;
 315   3            RunData.WorkCount_1s=0;
 316   3            RunData.WorkCount_60s++;
 317   3            //RunData.WorkTime_Second++;
 318   3            if ( RunData.WorkCount_60s>=60 )
 319   3            {
 320   4              RunData.WorkCount_60s=0;
 321   4            }
 322   3          }
 323   2      
 324   2        }
 325   1      
 326   1      
 327   1      }
 328          
 329          
 330          
 331          
 332          
 333          
 334          void Timer0_Init()
 335          {
 336   1      
 337   1        TMOD = ( ( TMOD&~0X03 ) |T0_Mode1 ); //模式1 16位定时器/计数器(TMOD &~ TMOD_TMOD0_MASK)|1<<TMOD_TMOD0_POS
             -;
 338   1      
 339   1        TH0 = 0xc6;    // timer0 高字节数据
 340   1        TL0 = 0x66;    // timer0 低字节数据
 341   1        ET0 = 1;
 342   1        TF0 = 0;
 343   1        TR0 =1 ;
 344   1      }
 345          
 346          
 347          
 348          
 349          
 350          
 351          
 352          
 353          
 354          
 355          
 356          
 357          
 358          
 359          
 360          
 361          


C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          07/10/2021 09:48:14 PAGE 7   

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1068    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----     100
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1       2
   IDATA SIZE       =   ----       2
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
