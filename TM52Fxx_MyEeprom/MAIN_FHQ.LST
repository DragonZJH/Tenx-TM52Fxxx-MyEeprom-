C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          07/09/2021 14:29:48 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN_FHQ
OBJECT MODULE PLACED IN MAIN_FHQ.OBJ
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE MAIN_FHQ.c OPTIMIZE(9,SIZE) BROWSE INCDIR(.\Drivers) DEBUG OBJECTEXTEND 
                    -TABS(2)

line level    source

   1          
   2          
   3          
   4          /**************************** MyEeprom 模块概述**********************************
   5          *********************************************************************************
   6              TM52Fxx系列芯片 内部EEPROM擦写次数为最小大于5万次,即单个地址的擦写次数是有限的
   7           随着擦写次数的增加每次擦写的时间会有所延长，虽然对于一般不需要经常操作EEPROM的应
   8           用5-10万的擦写次数完全可以满足整个芯片使用周期，但有些应用需要更加频繁的保存/读取
   9           数据则需要芯片能够提供足够多的擦写次数。本DEMO主要为了有以上需要的朋友们提供一个很
  10           好的解决方案.
  11              DEMO的大致原理就是在芯片提供的整个EEPROM空间内，根据用户需要保存数据的大小,自动
  12           分配N个区域,根据数据写入的次数动态地把用户数据保存在这些区域中，在芯片使用周期内确
  13           保整个EEPROM空间使用率得到很好的平衡。理论上可以就达到了延长芯片EEPROM的使用寿命的
  14           目的，使用寿命将延长至原来的xN(区域)倍。经压力测试每秒擦写20-30次保存15字节数据擦写
  15           次数已经超过18万次多，数据没有发现异常.
  16          
  17           模块配置使用步骤----MyEeprom.h头文件
  18               1：根据提示修改以下宏定义     
  19                  #define ChipEepromRamCP  256     //芯片EepromRam的容量大小
  20                  #define EepromStartAddr  0XEE00   //这个芯片EEPROM物理内存中起始地址
  21                  #define TM52FE8276_TotalEeprom  128  //这个芯片总共可以使用的EEPROM字节，TM52f82xx芯片偶地址有效
  22          
  23               2：在枚举项@AllEepromAddr加入你需要保存数据的地址名称
  24                  注意枚举中前后两个项不能更改
  25          
  26               3：如果需要调试或其他测试，设置宏定义 TestEeprom  为TRUE  
  27               
  28           模块配置使用步骤----MyEeprom.c文件
  29               1：在工程初始化调用函数 MyEepromInit()
  30          
  31               2：根据提示修改此接口函数内部MyEepromSaveAllDataUserHandle (  )
  32          
  33               3：单个数据写调用--MyEepromWrite ( unsigned int,unsigned char ,unsigned char )
  34                  单个数据读调用--unsigned char MyEepromRead(unsigned char)
  35          
  36                  测试时接口--    MyEepromTestHandle ( char* from,unsigned char flag )
  37           
  38          
  39           ******************************************************************************
  40          
  41          ******************************************************************************/
  42          
  43          
  44          
  45          #include "TM52F82XX_Eeprom.h"
  46          #include "MyEeprom.h"
  47          
  48          #include "DEFINE.H"
  49          
  50          
  51          #include "Uart.h"
  52          
  53          #include "Delay.h"
  54          #include "LED.h"
C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          07/09/2021 14:29:48 PAGE 2   

  55          
  56          
  57          #include  <intrins.h>
  58          
  59          #include <REGtenxTM52FE8276.h>
  60          
  61          
  62          
  63          
  64          void     Timer0_Init();
  65          void         SetLEDDisplay();
  66          
  67          
  68          
  69          /* 快时钟系统主频为 14.7456M
  70           */
  71          void bsp_clock_init()
  72          {
  73   1        SELFCK = 0;      //切换到慢时钟
  74   1        SYSCLOCK_DIV_1;   //div 1时钟分频
  75   1        Delay30us();
  76   1        SELFCK = 1;     //切换到快时钟
  77   1      }
  78          
  79          void SystemInit()
  80          {
  81   1        unsigned char t;
  82   1      
  83   1        for ( t=0; t<10; t++ )
  84   1        {
  85   2          Delay10Ms();
  86   2        }
  87   1        bsp_clock_init();
  88   1        MyEepromInit();
  89   1        UartInit();
  90   1        Timer0_Init();
  91   1      
  92   1          MyEeprom.EepromTestWriteCount=0;
  93   1        ReadSameDataFromEeprom();
  94   1        
  95   1        WDTPSC0;//WDT 480MS
  96   1        WDT_RUN_FAST_DIS_ILDE;
  97   1      
  98   1        EA=1;
  99   1      }
 100          
 101          void ClearXRAM ( void )
 102          {
 103   1        unsigned char xdata* data l_p_ucXdata;
 104   1        unsigned int idata i;
 105   1        l_p_ucXdata = 0xfd00;
 106   1        for ( i = 0; i < 768; i++ )
 107   1        {
 108   2          * ( l_p_ucXdata++ ) = 0x00;
 109   2        }
 110   1      }
 111          
 112          
 113          #if TestEeprom==TRUE
 114          //需要用户自行加入LED显示模块
 115          void SetLEDDisplay()
 116          {
C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          07/09/2021 14:29:48 PAGE 3   

 117   1      
 118   1          //eeprom测试用
 119   1        if ( RunData.WorkCount_60s<20 )
 120   1        {
 121   2          MyEepromTestHandle  ( ( char* ) LEDShow,'C' ); //LED显示相应区域
 122   2        }
 123   1        else
 124   1        {
 125   2          MyEepromTestHandle ( ( char* ) LEDShow,'D' );//LED显示总写入次数
 126   2        }
 127   1      }
 128          
 129          #endif
 130          
 131          #if TestEeprom
 132          unsigned char GetHex(unsigned char dat )
 133          {
 134   1        if(dat==0)
 135   1          return 0x30;
 136   1       if(dat<10)
 137   1          return dat+0x30;
 138   1        else
 139   1          return dat+0x37;
 140   1          
 141   1      }
 142          
 143          #endif
 144          
 145          
 146          void SendToUart()
 147          {
 148   1         #if TestEeprom==TRUE
 149   1         /***********************************************************
 150   1           每1S发送一次
 151   1           注意因为过快的写入和读取时间导致有些参数始终没有变化的问题
 152   1         ************************************************************/
 153   1        if ( ( RunData.SendDataToUartCount >=1 )  ) 
 154   1        {
 155   2      
 156   2          unsigned char xdata send[100];
 157   2          unsigned char  t=0;
 158   2          MyEepromTestHandle ( FALSE,'A' );
 159   2      
 160   2          ReadSameDataFromEeprom();
 161   2      
 162   2          send[t++]=  'M' ;
 163   2          send[t++]=  'y' ;
 164   2          send[t++]= 'E' ;
 165   2          send[t++]=  'e' ;
 166   2          send[t++]=  'p' ;
 167   2          send[t++]=  'r' ;
 168   2          send[t++]= 'o' ;
 169   2          send[t++]=  'm' ;
 170   2          send[t++]= 'T' ;
 171   2          send[t++]=  'e' ;
 172   2          send[t++]=  's' ;
 173   2          send[t++]=  't' ;
 174   2          send[t++]=  ':' ;
 175   2          send[t++]=  '\r' ;
 176   2          send[t++]=  '\n' ;
 177   2      
 178   2          send[t++]=  '[' ;
C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          07/09/2021 14:29:48 PAGE 4   

 179   2          send[t++]=  'T' ;
 180   2          send[t++]=  'i' ;
 181   2          send[t++]=  'm' ;
 182   2          send[t++]=  'e' ;
 183   2          send[t++]=  ':' ;
 184   2          send[t++]=  ( RunData.WorkTime_Second/10000+0x30 );
 185   2          send[t++]=  ( RunData.WorkTime_Second%10000/1000+0x30 );
 186   2          send[t++]=  ( RunData.WorkTime_Second%1000/100+0x30 );
 187   2          send[t++]=  ( RunData.WorkTime_Second%100/10+0x30 );
 188   2          send[t++]=  ( RunData.WorkTime_Second%10+0x30 );
 189   2          send[t++]=  ']' ;
 190   2          send[t++]=  '-' ;
 191   2      
 192   2          send[t++]=  '[' ;
 193   2          send[t++]=  GetHex(RunData.FD_Count>>12);
 194   2          send[t++]=  GetHex((RunData.FD_Count>>8)&0x000f);
 195   2          send[t++]=  GetHex((RunData.FD_Count>>4)&0x000f);
 196   2          send[t++]=  GetHex(RunData.FD_Count&0x000f);
 197   2          send[t++]=   ']' ;
 198   2          send[t++]=  '-' ;
 199   2      
 200   2              send[t++]=  '[' ;
 201   2          send[t++]=  GetHex( SetData.FH_Mode>>8 );
 202   2          send[t++]=  GetHex( SetData.FH_Mode&0x0f);
 203   2          send[t++]=  ']' ;
 204   2          send[t++]=  '-' ;
 205   2          
 206   2          send[t++]= '[' ;
 207   2          send[t++]= GetHex( SetData.SetTemp>>12);
 208   2          send[t++]= GetHex( (SetData.SetTemp>>8)&0x000f);
 209   2          send[t++]= GetHex( (SetData.SetTemp>>4)&0x000f );
 210   2          send[t++]= GetHex( SetData.SetTemp&0x000f);
 211   2          send[t++]=  ']' ;
 212   2          send[t++]=  '-' ;
 213   2      
 214   2          send[t++]= '[' ;
 215   2          send[t++]= GetHex( SetData.SetHumidity>>8 );
 216   2          send[t++]= GetHex( SetData.SetHumidity&0x0f );
 217   2          send[t++]= ']' ;
 218   2          send[t++]=  '-' ;
 219   2      
 220   2      
 221   2          send[t++]=  '[' ;
 222   2          send[t++]=  ( MyEeprom.EepromTestWriteCount  /1000000+0x30 );
 223   2          send[t++]=  ( MyEeprom.EepromTestWriteCount %1000000/100000+0x30 );
 224   2          send[t++]=  ( MyEeprom.EepromTestWriteCount %100000/10000+0x30 );
 225   2          send[t++]=  ( MyEeprom.EepromTestWriteCount %10000/1000+0x30 );
 226   2          send[t++]=  ( MyEeprom.EepromTestWriteCount %1000/100+0x30 );
 227   2          send[t++]=  ( MyEeprom.EepromTestWriteCount %100/10+0x30 );
 228   2          send[t++]=  ( MyEeprom.EepromTestWriteCount %10+0x30 );
 229   2          send[t++]=  ']' ;
 230   2          
 231   2      
 232   2          send[t++]= '\r' ;
 233   2          send[t++]=  '\n' ;
 234   2          send[t++]= '\r' ;
 235   2          send[t++]=  '\n' ;
 236   2          UartSendArray ( send, t );
 237   2      
 238   2          RunData.SendDataToUartCount=0;
 239   2        }
 240   1      
C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          07/09/2021 14:29:48 PAGE 5   

 241   1         #else
                  UartSendArray ( "---\r\n", 5 );
                 #endif
 244   1      }
 245          
 246          
 247          
 248          
 249          void main ()
 250          {
 251   1      
 252   1        bsp_clock_init();  //快时钟系统主频为 14.7456M/2 = 7.3728M
 253   1        ClearXRAM();
 254   1        SystemInit();
 255   1      
 256   1      
 257   1        P0OE|= ( 1<<7 );
 258   1          P0_7=1;
 259   1      
 260   1        while ( 1 )
 261   1        {
 262   2        
 263   2              if(RunData.WorkCount_60s%5==0)
 264   2               P0_7=1;
 265   2               else if(RunData.WorkCount_60s%7==0)
 266   2               P0_7=0;
 267   2               
 268   2      #if TestEeprom==TRUE
 269   2              //EEPROM写入测试
 270   2          MyEepromTestHandle ((char*)(&RunData.WorkCount_10ms) ,'B' ); 
 271   2          //写入LED缓冲区显示查看
 272   2          SetLEDDisplay(); 
 273   2      #endif    
 274   2      
 275   2          //数据发送到串口查看
 276   2          SendToUart();
 277   2      
 278   2        }
 279   1      }
 280          
 281          
 282          
 283          
 284          
 285          
 286          void ISR_TIMER0() interrupt 1  //2ms
 287          
 288          {
 289   1      
 290   1      
 291   1        static unsigned char Count_10Ms;
 292   1      
 293   1        TH0 = 0xc6; // timer0 高字节数据
 294   1        TL0 = 0x66+16;  // timer0 低字节数据
 295   1      
 296   1        CLR_WDT;
 297   1      
 298   1        //Uart_SetTimeOut();
 299   1      
 300   1        Count_10Ms++;
 301   1        if ( Count_10Ms>=5 )
 302   1        {
C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          07/09/2021 14:29:48 PAGE 6   

 303   2          Count_10Ms=0;
 304   2          RunData.WorkCount_10ms++;
 305   2          RunData.WorkCount_1s++;
 306   2          RunData.WorkTime_Second++;
 307   2          if ( RunData.WorkCount_1s>=100 )
 308   2          {
 309   3            RunData.SendDataToUartCount++;
 310   3            RunData.WorkCount_1s=0;
 311   3            RunData.WorkCount_60s++;
 312   3            //RunData.WorkTime_Second++;
 313   3            if ( RunData.WorkCount_60s>=60 )
 314   3            {
 315   4              RunData.WorkCount_60s=0;
 316   4            }
 317   3          }
 318   2      
 319   2        }
 320   1      
 321   1      
 322   1      }
 323          
 324          
 325          
 326          
 327          
 328          
 329          void Timer0_Init()
 330          {
 331   1      
 332   1        TMOD = ( ( TMOD&~0X03 ) |T0_Mode1 ); //模式1 16位定时器/计数器(TMOD &~ TMOD_TMOD0_MASK)|1<<TMOD_TMOD0_POS
             -;
 333   1      
 334   1        TH0 = 0xc6;    // timer0 高字节数据
 335   1        TL0 = 0x66;    // timer0 低字节数据
 336   1        ET0 = 1;
 337   1        TF0 = 0;
 338   1        TR0 =1 ;
 339   1      }
 340          
 341          
 342          
 343          
 344          
 345          
 346          
 347          
 348          
 349          
 350          
 351          
 352          
 353          
 354          
 355          
 356          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1041    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----     100
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          07/09/2021 14:29:48 PAGE 7   

   DATA SIZE        =      1       2
   IDATA SIZE       =   ----       2
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
