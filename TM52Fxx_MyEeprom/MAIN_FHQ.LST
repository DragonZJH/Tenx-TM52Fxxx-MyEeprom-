C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          10/10/2021 11:30:27 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN_FHQ
OBJECT MODULE PLACED IN MAIN_FHQ.OBJ
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE MAIN_FHQ.c OPTIMIZE(9,SIZE) BROWSE INCDIR(.\Drivers) DEBUG OBJECTEXTEND 
                    -TABS(2)

line level    source

   1          
   2          
   3          
   4          /**************************** MyEeprom 模块概述**********************************
   5          *********************************************************************************
   6              TM52Fxx系列芯片 内部EEPROM擦写次数为最小大于5万次,即单个地址的擦写次数是有限的
   7           随着擦写次数的增加每次擦写的时间会有所延长，虽然对于一般不需要经常操作EEPROM的应
   8           用5-10万的擦写次数完全可以满足整个芯片使用周期，但有些应用需要更加频繁的保存/读取
   9           数据则需要芯片能够提供足够多的擦写次数。本DEMO主要为了有以上需要的朋友们提供一个很
  10           好的解决方案.
  11              DEMO的大致原理就是在芯片提供的整个EEPROM空间内，根据用户需要保存数据的大小,自动
  12           分配N个区域,根据数据写入的次数动态地把用户数据保存在这些区域中，在芯片使用周期内确
  13           保整个EEPROM空间使用率得到很好的平衡。理论上可以就达到了延长芯片EEPROM的使用寿命的
  14           目的，使用寿命将延长至原来的xN(区域)倍。经压力测试每秒擦写20-30次保存15字节数据擦写
  15           次数已经超过18万次多，数据没有发现异常.
  16          
  17           模块配置使用步骤----MyEeprom.h头文件
  18               1：根据提示修改以下宏定义
  19                  #define ChipEepromRamCP  256     //芯片EepromRam的容量大小
  20                  #define EepromStartAddr  0XEE00   //这个芯片EEPROM物理内存中起始地址
  21                  #define TM52FE8276_TotalEeprom  128  //这个芯片总共可以使用的EEPROM字节，TM52f82xx芯片偶地址有效
  22          
  23               2：在枚举项@AllEepromAddr加入你需要保存数据的地址名称
  24                  注意枚举中前后两个项不能更改
  25          
  26               3：如果需要调试或其他测试，设置宏定义 TestEeprom  为TRUE
  27          
  28           模块配置使用步骤----MyEeprom.c文件
  29               1：在工程初始化调用函数 MyEepromInit()
  30          
  31               2：根据提示修改此接口函数内部MyEepromSaveAllDataUserHandle (  )
  32          
  33               3：单个数据写调用--MyEepromWrite ( unsigned int,unsigned char ,unsigned char )
  34                  单个数据读调用--unsigned char MyEepromRead(unsigned char)
  35          
  36                  测试时接口--    MyEepromTestHandle ( char* from,unsigned char flag )
  37          
  38          
  39           其他：暂时只测试了十速TM52FE8273芯片，根据数据手册其他TM52FEXX系列应该也是可以通用的
  40                 移植到到其他只需需该修改部分代码，后续有时间继续更新
  41          
  42           感兴趣的朋友可以关注我github中的此开源项目提供宝贵意见
  43           仓库地址：https://github.com/DragonZJH/Tenx-TM52Fxxx-MyEeprom-
  44          
  45          ******************************************************************************
  46          
  47          ******************************************************************************/
  48          
  49          
  50          
  51          #include "TM52F82XX_Eeprom.h"
  52          #include "MyEeprom.h"
  53          
  54          #include "DEFINE.H"
C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          10/10/2021 11:30:27 PAGE 2   

  55          
  56          
  57          #include "Uart.h"
  58          
  59          #include "Delay.h"
  60          #include "LED.h"
  61          
  62          
  63          #include  <intrins.h>
  64          
  65          #include <REGtenxTM52FE8276.h>
  66          
  67          
  68          
  69          
  70          void     Timer0_Init();
  71          void         SetLEDDisplay();
  72          
  73          
  74          
  75          /* 快时钟系统主频为 14.7456M
  76           */
  77          void bsp_clock_init()
  78          {
  79   1        SELFCK = 0;      //切换到慢时钟
  80   1        SYSCLOCK_DIV_1;   //div 1时钟分频
  81   1        Delay30us();
  82   1        SELFCK = 1;     //切换到快时钟
  83   1      }
  84          
  85          void SystemInit()
  86          {
  87   1        unsigned char t;
  88   1      
  89   1        for ( t=0; t<10; t++ )
  90   1        {
  91   2          Delay10Ms();
  92   2        }
  93   1        bsp_clock_init();
  94   1        MyEepromInit();
  95   1        UartInit();
  96   1        Timer0_Init();
  97   1      
  98   1      #if TestEeprom==TRUE
  99   1        MyEeprom.EepromTestWriteCount=0;
 100   1      #endif
 101   1        ReadSameDataFromEeprom();
 102   1      
 103   1      
 104   1        WDTPSC0;//WDT 480MS
 105   1        WDT_RUN_FAST_DIS_ILDE;
 106   1      
 107   1        EA=1;
 108   1      }
 109          
 110          void ClearXRAM ( void )
 111          {
 112   1        unsigned char xdata* data l_p_ucXdata;
 113   1        unsigned int idata i;
 114   1        l_p_ucXdata = 0xfd00;
 115   1        for ( i = 0; i < 768; i++ )
 116   1        {
C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          10/10/2021 11:30:27 PAGE 3   

 117   2          * ( l_p_ucXdata++ ) = 0x00;
 118   2        }
 119   1      }
 120          
 121          
 122          #if TestEeprom==TRUE
 123          //需要用户自行加入LED显示模块
 124          void SetLEDDisplay()
 125          {
 126   1      
 127   1        //eeprom测试用
 128   1        if ( RunData.WorkCount_60s<20 )
 129   1        {
 130   2          MyEepromTestHandle  ( ( char* ) LEDShow,'C' ); //LED显示相应区域
 131   2        }
 132   1        else
 133   1        {
 134   2          MyEepromTestHandle ( ( char* ) LEDShow,'D' );//LED显示总写入次数
 135   2        }
 136   1      }
 137          
 138          #endif
 139          
 140          #if TestEeprom
 141          unsigned char GetHex ( unsigned char dat )
 142          {
 143   1        if ( dat==0 )
 144   1        {
 145   2          return 0x30;
 146   2        }
 147   1        if ( dat<10 )
 148   1        {
 149   2          return dat+0x30;
 150   2        }
 151   1        else
 152   1        {
 153   2          return dat+0x37;
 154   2        }
 155   1      
 156   1      }
 157          
 158          #endif
 159          
 160          
 161          void SendToUart()
 162          {
 163   1      
 164   1        /***********************************************************
 165   1          每1S发送一次
 166   1          注意因为过快的写入和读取时间导致有些参数始终没有变化的问题
 167   1        ************************************************************/
 168   1        if ( ( RunData.SendDataToUartCount >=1 )  )
 169   1        {
 170   2      #if TestEeprom==TRUE
 171   2          /***串口打印格式：
 172   2            MyEepromTest:
 173   2            [Time:62501]-[D35C]-[09]-[0000]-[0C]-[00201316]
 174   2              时间秒       - 参数1.2.3.4......       -总擦写次数
 175   2          ***/
 176   2          unsigned char xdata send[100];
 177   2          unsigned char  t=0;
 178   2          MyEepromTestHandle ( FALSE,'A' );
C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          10/10/2021 11:30:27 PAGE 4   

 179   2      
 180   2          ReadSameDataFromEeprom();
 181   2      
 182   2          send[t++]=  'M' ;
 183   2          send[t++]=  'y' ;
 184   2          send[t++]= 'E' ;
 185   2          send[t++]=  'e' ;
 186   2          send[t++]=  'p' ;
 187   2          send[t++]=  'r' ;
 188   2          send[t++]= 'o' ;
 189   2          send[t++]=  'm' ;
 190   2          send[t++]= 'T' ;
 191   2          send[t++]=  'e' ;
 192   2          send[t++]=  's' ;
 193   2          send[t++]=  't' ;
 194   2          send[t++]=  ':' ;
 195   2          send[t++]=  '\r' ;
 196   2          send[t++]=  '\n' ;
 197   2      
 198   2          send[t++]=  '[' ;
 199   2          send[t++]=  'T' ;
 200   2          send[t++]=  'i' ;
 201   2          send[t++]=  'm' ;
 202   2          send[t++]=  'e' ;
 203   2          send[t++]=  ':' ;
 204   2          send[t++]=  ( RunData.WorkTime_Second/10000+0x30 );
 205   2          send[t++]=  ( RunData.WorkTime_Second%10000/1000+0x30 );
 206   2          send[t++]=  ( RunData.WorkTime_Second%1000/100+0x30 );
 207   2          send[t++]=  ( RunData.WorkTime_Second%100/10+0x30 );
 208   2          send[t++]=  ( RunData.WorkTime_Second%10+0x30 );
 209   2          send[t++]=  ']' ;
 210   2          send[t++]=  '-' ;
 211   2      
 212   2          send[t++]=  '[' ;
 213   2          send[t++]=  GetHex ( RunData.FD_Count>>12 );
 214   2          send[t++]=  GetHex ( ( RunData.FD_Count>>8 ) &0x000f );
 215   2          send[t++]=  GetHex ( ( RunData.FD_Count>>4 ) &0x000f );
 216   2          send[t++]=  GetHex ( RunData.FD_Count&0x000f );
 217   2          send[t++]=   ']' ;
 218   2          send[t++]=  '-' ;
 219   2      
 220   2          send[t++]=  '[' ;
 221   2          send[t++]=  GetHex ( SetData.FH_Mode>>8 );
 222   2          send[t++]=  GetHex ( SetData.FH_Mode&0x0f );
 223   2          send[t++]=  ']' ;
 224   2          send[t++]=  '-' ;
 225   2      
 226   2          send[t++]= '[' ;
 227   2          send[t++]= GetHex ( SetData.SetTemp>>12 );
 228   2          send[t++]= GetHex ( ( SetData.SetTemp>>8 ) &0x000f );
 229   2          send[t++]= GetHex ( ( SetData.SetTemp>>4 ) &0x000f );
 230   2          send[t++]= GetHex ( SetData.SetTemp&0x000f );
 231   2          send[t++]=  ']' ;
 232   2          send[t++]=  '-' ;
 233   2      
 234   2          send[t++]= '[' ;
 235   2          send[t++]= GetHex ( SetData.SetHumidity>>8 );
 236   2          send[t++]= GetHex ( SetData.SetHumidity&0x0f );
 237   2          send[t++]= ']' ;
 238   2          send[t++]=  '-' ;
 239   2      
 240   2      
C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          10/10/2021 11:30:27 PAGE 5   

 241   2      
 242   2          send[t++]=  '[' ;
 243   2          send[t++]=  ( MyEeprom.EepromTestWriteCount /10000000+0x30 );
 244   2          send[t++]=  ( MyEeprom.EepromTestWriteCount %10000000/1000000+0x30 );
 245   2          send[t++]=  ( MyEeprom.EepromTestWriteCount %1000000/100000+0x30 );
 246   2          send[t++]=  ( MyEeprom.EepromTestWriteCount %100000/10000+0x30 );
 247   2          send[t++]=  ( MyEeprom.EepromTestWriteCount %10000/1000+0x30 );
 248   2          send[t++]=  ( MyEeprom.EepromTestWriteCount %1000/100+0x30 );
 249   2          send[t++]=  ( MyEeprom.EepromTestWriteCount %100/10+0x30 );
 250   2          send[t++]=  ( MyEeprom.EepromTestWriteCount %10+0x30 );
 251   2          send[t++]=  ']' ;
 252   2      
 253   2      
 254   2          send[t++]= '\r' ;
 255   2          send[t++]=  '\n' ;
 256   2          send[t++]= '\r' ;
 257   2          send[t++]=  '\n' ;
 258   2          UartSendArray ( send, t );
 259   2      #else
                  //测试未开启
                  UartSendArray ( "TestEeprom is set to FALSE\r\n", sizeof ( "TestEeprom is set to FALSE\r\n" ) );
              #endif
 263   2      
 264   2          RunData.SendDataToUartCount=0;
 265   2        }
 266   1      
 267   1      
 268   1      }
 269          
 270          
 271          
 272          
 273          void main ()
 274          {
 275   1      
 276   1        bsp_clock_init();  //快时钟系统主频为 14.7456M/2 = 7.3728M
 277   1        ClearXRAM();
 278   1        SystemInit();
 279   1      
 280   1      
 281   1        P0OE|= ( 1<<7 );
 282   1        LED_Test=LED_OFF;
 283   1      
 284   1        while ( 1 )
 285   1        {
 286   2      
 287   2          {   //P07接LED 上电LED小于6秒灭系统故障
 288   3            if ( RunData.WorkCount_60s%5==0 )
 289   3            {
 290   4              LED_Test=LED_ON;
 291   4            }
 292   3            else if ( RunData.WorkCount_60s%7==0 )
 293   3            {
 294   4              LED_Test=LED_OFF;
 295   4            }
 296   3          }
 297   2      #if TestEeprom==TRUE
 298   2          //EEPROM写入测试
 299   2          MyEepromTestHandle ( ( char* ) ( &RunData.WorkCount_10ms ),'B' );
 300   2          //写入LED缓冲区显示查看
 301   2          SetLEDDisplay();
 302   2      #endif
C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          10/10/2021 11:30:27 PAGE 6   

 303   2      
 304   2          //数据发送到串口查看
 305   2          SendToUart();
 306   2      
 307   2        }
 308   1      }
 309          
 310          
 311          
 312          
 313          
 314          
 315          void ISR_TIMER0() interrupt 1  //2ms
 316          
 317          {
 318   1      
 319   1      
 320   1        static unsigned char Count_10Ms;
 321   1      
 322   1        TH0 = 0xc6; // timer0 高字节数据
 323   1        TL0 = 0x66+16;  // timer0 低字节数据
 324   1      
 325   1        CLR_WDT;
 326   1      
 327   1        //Uart_SetTimeOut();
 328   1      
 329   1        Count_10Ms++;
 330   1        if ( Count_10Ms>=5 )
 331   1        {
 332   2          Count_10Ms=0;
 333   2          RunData.WorkCount_10ms++;
 334   2          RunData.WorkCount_1s++;
 335   2          RunData.WorkTime_Second++;
 336   2          if ( RunData.WorkCount_1s>=100 )
 337   2          {
 338   3            RunData.SendDataToUartCount++;
 339   3            RunData.WorkCount_1s=0;
 340   3            RunData.WorkCount_60s++;
 341   3            //RunData.WorkTime_Second++;
 342   3            if ( RunData.WorkCount_60s>=60 )
 343   3            {
 344   4              RunData.WorkCount_60s=0;
 345   4            }
 346   3          }
 347   2      
 348   2        }
 349   1      
 350   1      
 351   1      }
 352          
 353          
 354          
 355          
 356          
 357          
 358          void Timer0_Init()
 359          {
 360   1      
 361   1        TMOD = ( ( TMOD&~0X03 ) |T0_Mode1 ); //模式1 16位定时器/计数器(TMOD &~ TMOD_TMOD0_MASK)|1<<TMOD_TMOD0_POS
             -;
 362   1      
 363   1        TH0 = 0xc6;    // timer0 高字节数据
C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          10/10/2021 11:30:27 PAGE 7   

 364   1        TL0 = 0x66;    // timer0 低字节数据
 365   1        ET0 = 1;
 366   1        TF0 = 0;
 367   1        TR0 =1 ;
 368   1      }
 369          
 370          
 371          
 372          
 373          
 374          
 375          
 376          
 377          
 378          
 379          
 380          
 381          
 382          
 383          
 384          
 385          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1068    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----     100
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1       2
   IDATA SIZE       =   ----       2
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
