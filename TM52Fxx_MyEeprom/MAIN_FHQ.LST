C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          07/09/2021 14:58:18 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN_FHQ
OBJECT MODULE PLACED IN MAIN_FHQ.OBJ
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE MAIN_FHQ.c OPTIMIZE(9,SIZE) BROWSE INCDIR(.\Drivers) DEBUG OBJECTEXTEND 
                    -TABS(2)

line level    source

   1          
   2          
   3          
   4          /**************************** MyEeprom 模块概述**********************************
   5          *********************************************************************************
   6              TM52Fxx系列芯片 内部EEPROM擦写次数为最小大于5万次,即单个地址的擦写次数是有限的
   7           随着擦写次数的增加每次擦写的时间会有所延长，虽然对于一般不需要经常操作EEPROM的应
   8           用5-10万的擦写次数完全可以满足整个芯片使用周期，但有些应用需要更加频繁的保存/读取
   9           数据则需要芯片能够提供足够多的擦写次数。本DEMO主要为了有以上需要的朋友们提供一个很
  10           好的解决方案.
  11              DEMO的大致原理就是在芯片提供的整个EEPROM空间内，根据用户需要保存数据的大小,自动
  12           分配N个区域,根据数据写入的次数动态地把用户数据保存在这些区域中，在芯片使用周期内确
  13           保整个EEPROM空间使用率得到很好的平衡。理论上可以就达到了延长芯片EEPROM的使用寿命的
  14           目的，使用寿命将延长至原来的xN(区域)倍。经压力测试每秒擦写20-30次保存15字节数据擦写
  15           次数已经超过18万次多，数据没有发现异常.
  16          
  17           模块配置使用步骤----MyEeprom.h头文件
  18               1：根据提示修改以下宏定义     
  19                  #define ChipEepromRamCP  256     //芯片EepromRam的容量大小
  20                  #define EepromStartAddr  0XEE00   //这个芯片EEPROM物理内存中起始地址
  21                  #define TM52FE8276_TotalEeprom  128  //这个芯片总共可以使用的EEPROM字节，TM52f82xx芯片偶地址有效
  22          
  23               2：在枚举项@AllEepromAddr加入你需要保存数据的地址名称
  24                  注意枚举中前后两个项不能更改
  25          
  26               3：如果需要调试或其他测试，设置宏定义 TestEeprom  为TRUE  
  27               
  28           模块配置使用步骤----MyEeprom.c文件
  29               1：在工程初始化调用函数 MyEepromInit()
  30          
  31               2：根据提示修改此接口函数内部MyEepromSaveAllDataUserHandle (  )
  32          
  33               3：单个数据写调用--MyEepromWrite ( unsigned int,unsigned char ,unsigned char )
  34                  单个数据读调用--unsigned char MyEepromRead(unsigned char)
  35          
  36                  测试时接口--    MyEepromTestHandle ( char* from,unsigned char flag )
  37           
  38          
  39           ******************************************************************************
  40          
  41          ******************************************************************************/
  42          
  43          
  44          
  45          #include "TM52F82XX_Eeprom.h"
  46          #include "MyEeprom.h"
  47          
  48          #include "DEFINE.H"
  49          
  50          
  51          #include "Uart.h"
  52          
  53          #include "Delay.h"
  54          #include "LED.h"
C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          07/09/2021 14:58:18 PAGE 2   

  55          
  56          
  57          #include  <intrins.h>
  58          
  59          #include <REGtenxTM52FE8276.h>
  60          
  61          
  62          
  63          
  64          void     Timer0_Init();
  65          void         SetLEDDisplay();
  66          
  67          
  68          
  69          /* 快时钟系统主频为 14.7456M
  70           */
  71          void bsp_clock_init()
  72          {
  73   1        SELFCK = 0;      //切换到慢时钟
  74   1        SYSCLOCK_DIV_1;   //div 1时钟分频
  75   1        Delay30us();
  76   1        SELFCK = 1;     //切换到快时钟
  77   1      }
  78          
  79          void SystemInit()
  80          {
  81   1        unsigned char t;
  82   1      
  83   1        for ( t=0; t<10; t++ )
  84   1        {
  85   2          Delay10Ms();
  86   2        }
  87   1        bsp_clock_init();
  88   1        MyEepromInit();
  89   1        UartInit();
  90   1        Timer0_Init();
  91   1      
  92   1        #if TestEeprom==TRUE
                MyEeprom.EepromTestWriteCount=0;
                  #endif
  95   1        ReadSameDataFromEeprom();
  96   1      
  97   1        
  98   1        WDTPSC0;//WDT 480MS
  99   1        WDT_RUN_FAST_DIS_ILDE;
 100   1      
 101   1        EA=1;
 102   1      }
 103          
 104          void ClearXRAM ( void )
 105          {
 106   1        unsigned char xdata* data l_p_ucXdata;
 107   1        unsigned int idata i;
 108   1        l_p_ucXdata = 0xfd00;
 109   1        for ( i = 0; i < 768; i++ )
 110   1        {
 111   2          * ( l_p_ucXdata++ ) = 0x00;
 112   2        }
 113   1      }
 114          
 115          
 116          #if TestEeprom==TRUE
C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          07/09/2021 14:58:18 PAGE 3   

              //需要用户自行加入LED显示模块
              void SetLEDDisplay()
              {
              
                  //eeprom测试用
                if ( RunData.WorkCount_60s<20 )
                {
                  MyEepromTestHandle  ( ( char* ) LEDShow,'C' ); //LED显示相应区域
                }
                else
                {
                  MyEepromTestHandle ( ( char* ) LEDShow,'D' );//LED显示总写入次数
                }
              }
              
              #endif
 133          
 134          #if TestEeprom
              unsigned char GetHex(unsigned char dat )
              {
                if(dat==0)
                  return 0x30;
               if(dat<10)
                  return dat+0x30;
                else
                  return dat+0x37;
                  
              }
              
              #endif
 147          
 148          
 149          void SendToUart()
 150          {
 151   1         #if TestEeprom==TRUE
                 /***********************************************************
                   每1S发送一次
                   注意因为过快的写入和读取时间导致有些参数始终没有变化的问题
                 ************************************************************/
                if ( ( RunData.SendDataToUartCount >=1 )  ) 
                {
              
                  unsigned char xdata send[100];
                  unsigned char  t=0;
                  MyEepromTestHandle ( FALSE,'A' );
              
                  ReadSameDataFromEeprom();
              
                  send[t++]=  'M' ;
                  send[t++]=  'y' ;
                  send[t++]= 'E' ;
                  send[t++]=  'e' ;
                  send[t++]=  'p' ;
                  send[t++]=  'r' ;
                  send[t++]= 'o' ;
                  send[t++]=  'm' ;
                  send[t++]= 'T' ;
                  send[t++]=  'e' ;
                  send[t++]=  's' ;
                  send[t++]=  't' ;
                  send[t++]=  ':' ;
                  send[t++]=  '\r' ;
C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          07/09/2021 14:58:18 PAGE 4   

                  send[t++]=  '\n' ;
              
                  send[t++]=  '[' ;
                  send[t++]=  'T' ;
                  send[t++]=  'i' ;
                  send[t++]=  'm' ;
                  send[t++]=  'e' ;
                  send[t++]=  ':' ;
                  send[t++]=  ( RunData.WorkTime_Second/10000+0x30 );
                  send[t++]=  ( RunData.WorkTime_Second%10000/1000+0x30 );
                  send[t++]=  ( RunData.WorkTime_Second%1000/100+0x30 );
                  send[t++]=  ( RunData.WorkTime_Second%100/10+0x30 );
                  send[t++]=  ( RunData.WorkTime_Second%10+0x30 );
                  send[t++]=  ']' ;
                  send[t++]=  '-' ;
              
                  send[t++]=  '[' ;
                  send[t++]=  GetHex(RunData.FD_Count>>12);
                  send[t++]=  GetHex((RunData.FD_Count>>8)&0x000f);
                  send[t++]=  GetHex((RunData.FD_Count>>4)&0x000f);
                  send[t++]=  GetHex(RunData.FD_Count&0x000f);
                  send[t++]=   ']' ;
                  send[t++]=  '-' ;
              
                      send[t++]=  '[' ;
                  send[t++]=  GetHex( SetData.FH_Mode>>8 );
                  send[t++]=  GetHex( SetData.FH_Mode&0x0f);
                  send[t++]=  ']' ;
                  send[t++]=  '-' ;
                  
                  send[t++]= '[' ;
                  send[t++]= GetHex( SetData.SetTemp>>12);
                  send[t++]= GetHex( (SetData.SetTemp>>8)&0x000f);
                  send[t++]= GetHex( (SetData.SetTemp>>4)&0x000f );
                  send[t++]= GetHex( SetData.SetTemp&0x000f);
                  send[t++]=  ']' ;
                  send[t++]=  '-' ;
              
                  send[t++]= '[' ;
                  send[t++]= GetHex( SetData.SetHumidity>>8 );
                  send[t++]= GetHex( SetData.SetHumidity&0x0f );
                  send[t++]= ']' ;
                  send[t++]=  '-' ;
              
              
                  send[t++]=  '[' ;
                  send[t++]=  ( MyEeprom.EepromTestWriteCount  /1000000+0x30 );
                  send[t++]=  ( MyEeprom.EepromTestWriteCount %1000000/100000+0x30 );
                  send[t++]=  ( MyEeprom.EepromTestWriteCount %100000/10000+0x30 );
                  send[t++]=  ( MyEeprom.EepromTestWriteCount %10000/1000+0x30 );
                  send[t++]=  ( MyEeprom.EepromTestWriteCount %1000/100+0x30 );
                  send[t++]=  ( MyEeprom.EepromTestWriteCount %100/10+0x30 );
                  send[t++]=  ( MyEeprom.EepromTestWriteCount %10+0x30 );
                  send[t++]=  ']' ;
                  
              
                  send[t++]= '\r' ;
                  send[t++]=  '\n' ;
                  send[t++]= '\r' ;
                  send[t++]=  '\n' ;
                  UartSendArray ( send, t );
              
C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          07/09/2021 14:58:18 PAGE 5   

                  RunData.SendDataToUartCount=0;
                }
              
                 #else
 245   1          UartSendArray ( "---\r\n", 5 );
 246   1         #endif
 247   1      }
 248          
 249          
 250          
 251          
 252          void main ()
 253          {
 254   1      
 255   1        bsp_clock_init();  //快时钟系统主频为 14.7456M/2 = 7.3728M
 256   1        ClearXRAM();
 257   1        SystemInit();
 258   1      
 259   1      
 260   1        P0OE|= ( 1<<7 );
 261   1          P0_7=1;
 262   1      
 263   1        while ( 1 )
 264   1        {
 265   2        
 266   2              if(RunData.WorkCount_60s%5==0)
 267   2               P0_7=1;
 268   2               else if(RunData.WorkCount_60s%7==0)
 269   2               P0_7=0;
 270   2               
 271   2      #if TestEeprom==TRUE
                      //EEPROM写入测试
                  MyEepromTestHandle ((char*)(&RunData.WorkCount_10ms) ,'B' ); 
                  //写入LED缓冲区显示查看
                  SetLEDDisplay(); 
              #endif    
 277   2      
 278   2          //数据发送到串口查看
 279   2          SendToUart();
 280   2      
 281   2        }
 282   1      }
 283          
 284          
 285          
 286          
 287          
 288          
 289          void ISR_TIMER0() interrupt 1  //2ms
 290          
 291          {
 292   1      
 293   1      
 294   1        static unsigned char Count_10Ms;
 295   1      
 296   1        TH0 = 0xc6; // timer0 高字节数据
 297   1        TL0 = 0x66+16;  // timer0 低字节数据
 298   1      
 299   1        CLR_WDT;
 300   1      
 301   1        //Uart_SetTimeOut();
 302   1      
C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          07/09/2021 14:58:18 PAGE 6   

 303   1        Count_10Ms++;
 304   1        if ( Count_10Ms>=5 )
 305   1        {
 306   2          Count_10Ms=0;
 307   2          RunData.WorkCount_10ms++;
 308   2          RunData.WorkCount_1s++;
 309   2          RunData.WorkTime_Second++;
 310   2          if ( RunData.WorkCount_1s>=100 )
 311   2          {
 312   3            RunData.SendDataToUartCount++;
 313   3            RunData.WorkCount_1s=0;
 314   3            RunData.WorkCount_60s++;
 315   3            //RunData.WorkTime_Second++;
 316   3            if ( RunData.WorkCount_60s>=60 )
 317   3            {
 318   4              RunData.WorkCount_60s=0;
 319   4            }
 320   3          }
 321   2      
 322   2        }
 323   1      
 324   1      
 325   1      }
 326          
 327          
 328          
 329          
 330          
 331          
 332          void Timer0_Init()
 333          {
 334   1      
 335   1        TMOD = ( ( TMOD&~0X03 ) |T0_Mode1 ); //模式1 16位定时器/计数器(TMOD &~ TMOD_TMOD0_MASK)|1<<TMOD_TMOD0_POS
             -;
 336   1      
 337   1        TH0 = 0xc6;    // timer0 高字节数据
 338   1        TL0 = 0x66;    // timer0 低字节数据
 339   1        ET0 = 1;
 340   1        TF0 = 0;
 341   1        TR0 =1 ;
 342   1      }
 343          
 344          
 345          
 346          
 347          
 348          
 349          
 350          
 351          
 352          
 353          
 354          
 355          
 356          
 357          
 358          
 359          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    256    ----
C51 COMPILER V9.56.0.0   MAIN_FHQ                                                          07/09/2021 14:58:18 PAGE 7   

   CONSTANT SIZE    =      6    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1       1
   IDATA SIZE       =   ----       2
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
